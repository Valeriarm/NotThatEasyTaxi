{"ast":null,"code":"import _objectWithoutProperties from \"/home/linux/Escritorio/prueba/proyecto1/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties\";\nimport _classCallCheck from \"/home/linux/Escritorio/prueba/proyecto1/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/linux/Escritorio/prueba/proyecto1/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"/home/linux/Escritorio/prueba/proyecto1/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/home/linux/Escritorio/prueba/proyecto1/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _get from \"/home/linux/Escritorio/prueba/proyecto1/node_modules/@babel/runtime/helpers/esm/get\";\nimport _inherits from \"/home/linux/Escritorio/prueba/proyecto1/node_modules/@babel/runtime/helpers/esm/inherits\";\nvar _jsxFileName = \"/home/linux/Escritorio/prueba/proyecto1/src/componentes/MiMapa.js\";\nimport { latLngBounds, Map as LeafletMap } from 'leaflet';\nimport React from 'react';\nimport { LeafletProvider } from './context';\nimport MapEvented from './MapEvented';\nimport updateClassName from './utils/updateClassName';\nimport omit from './utils/omit';\nimport { LatLng, LatLngBounds, LeafletContext, Point, Viewport } from './types';\nvar OTHER_PROPS = ['children', 'className', 'id', 'style', 'useFlyTo', 'whenReady'];\n\nvar normalizeCenter = function normalizeCenter(pos) {\n  return Array.isArray(pos) ? [pos[0], pos[1]] : [pos.lat, pos.lon ? pos.lon : pos.lng];\n};\n\nvar Map =\n/*#__PURE__*/\nfunction (_MapEvented) {\n  _inherits(Map, _MapEvented);\n\n  function Map(props) {\n    var _this;\n\n    _classCallCheck(this, Map);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Map).call(this, props));\n    _this.viewport = {\n      center: undefined,\n      zoom: undefined\n    };\n    _this._ready = false;\n    _this._updating = false;\n\n    _this.onViewportChange = function () {\n      var center = _this.leafletElement.getCenter();\n\n      _this.viewport = {\n        center: center ? [center.lat, center.lng] : undefined,\n        zoom: _this.leafletElement.getZoom()\n      };\n\n      if (_this.props.onViewportChange && !_this._updating) {\n        _this.props.onViewportChange(_this.viewport);\n      }\n    };\n\n    _this.onViewportChanged = function () {\n      if (_this.props.onViewportChanged && !_this._updating) {\n        _this.props.onViewportChanged(_this.viewport);\n      }\n    };\n\n    _this.bindContainer = function (container) {\n      _this.container = container;\n    };\n\n    _this.className = props.className;\n    return _this;\n  }\n\n  _createClass(Map, [{\n    key: \"createLeafletElement\",\n    value: function createLeafletElement(props) {\n      var viewport = props.viewport,\n          options = _objectWithoutProperties(props, [\"viewport\"]);\n\n      if (viewport) {\n        if (viewport.center) {\n          options.center = viewport.center;\n        }\n\n        if (typeof viewport.zoom === 'number') {\n          options.zoom = viewport.zoom;\n        }\n      }\n\n      return new LeafletMap(this.container, options);\n    }\n  }, {\n    key: \"updateLeafletElement\",\n    value: function updateLeafletElement(fromProps, toProps) {\n      this._updating = true;\n      var animate = toProps.animate,\n          bounds = toProps.bounds,\n          boundsOptions = toProps.boundsOptions,\n          boxZoom = toProps.boxZoom,\n          center = toProps.center,\n          className = toProps.className,\n          doubleClickZoom = toProps.doubleClickZoom,\n          dragging = toProps.dragging,\n          keyboard = toProps.keyboard,\n          maxBounds = toProps.maxBounds,\n          scrollWheelZoom = toProps.scrollWheelZoom,\n          tap = toProps.tap,\n          touchZoom = toProps.touchZoom,\n          useFlyTo = toProps.useFlyTo,\n          viewport = toProps.viewport,\n          zoom = toProps.zoom;\n      updateClassName(this.container, fromProps.className, className);\n\n      if (viewport && viewport !== fromProps.viewport) {\n        var c = viewport.center ? viewport.center : center;\n        var z = viewport.zoom == null ? zoom : viewport.zoom;\n\n        if (useFlyTo === true) {\n          this.leafletElement.flyTo(c, z, {\n            animate: animate\n          });\n        } else {\n          this.leafletElement.setView(c, z, {\n            animate: animate\n          });\n        }\n      } else if (center && this.shouldUpdateCenter(center, fromProps.center)) {\n        if (useFlyTo === true) {\n          this.leafletElement.flyTo(center, zoom, {\n            animate: animate\n          });\n        } else {\n          this.leafletElement.setView(center, zoom, {\n            animate: animate\n          });\n        }\n      } else if (typeof zoom === 'number' && zoom !== fromProps.zoom) {\n        if (fromProps.zoom == null) {\n          this.leafletElement.setView(center, zoom);\n        } else {\n          this.leafletElement.setZoom(zoom);\n        }\n      }\n\n      if (maxBounds && this.shouldUpdateBounds(maxBounds, fromProps.maxBounds)) {\n        this.leafletElement.setMaxBounds(maxBounds);\n      }\n\n      if (bounds && (this.shouldUpdateBounds(bounds, fromProps.bounds) || boundsOptions !== fromProps.boundsOptions)) {\n        if (useFlyTo === true) {\n          this.leafletElement.flyToBounds(bounds, boundsOptions);\n        } else {\n          this.leafletElement.fitBounds(bounds, boundsOptions);\n        }\n      }\n\n      if (boxZoom !== fromProps.boxZoom) {\n        if (boxZoom === true) {\n          this.leafletElement.boxZoom.enable();\n        } else {\n          this.leafletElement.boxZoom.disable();\n        }\n      }\n\n      if (doubleClickZoom !== fromProps.doubleClickZoom) {\n        if (doubleClickZoom === true) {\n          this.leafletElement.doubleClickZoom.enable();\n        } else {\n          this.leafletElement.doubleClickZoom.disable();\n        }\n      }\n\n      if (dragging !== fromProps.dragging) {\n        if (dragging === true) {\n          this.leafletElement.dragging.enable();\n        } else {\n          this.leafletElement.dragging.disable();\n        }\n      }\n\n      if (keyboard !== fromProps.keyboard) {\n        if (keyboard === true) {\n          this.leafletElement.keyboard.enable();\n        } else {\n          this.leafletElement.keyboard.disable();\n        }\n      }\n\n      if (scrollWheelZoom !== fromProps.scrollWheelZoom) {\n        if (scrollWheelZoom === true || typeof scrollWheelZoom === 'string') {\n          this.leafletElement.options.scrollWheelZoom = scrollWheelZoom;\n          this.leafletElement.scrollWheelZoom.enable();\n        } else {\n          this.leafletElement.scrollWheelZoom.disable();\n        }\n      }\n\n      if (tap !== fromProps.tap) {\n        if (tap === true) {\n          this.leafletElement.tap.enable();\n        } else {\n          this.leafletElement.tap.disable();\n        }\n      }\n\n      if (touchZoom !== fromProps.touchZoom) {\n        if (touchZoom === true || typeof touchZoom === 'string') {\n          this.leafletElement.options.touchZoom = touchZoom;\n          this.leafletElement.touchZoom.enable();\n        } else {\n          this.leafletElement.touchZoom.disable();\n        }\n      }\n\n      this._updating = false;\n    }\n  }, {\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      var props = omit.apply(void 0, [this.props].concat(OTHER_PROPS));\n      this.leafletElement = this.createLeafletElement(props);\n      this.leafletElement.on('move', this.onViewportChange);\n      this.leafletElement.on('moveend', this.onViewportChanged);\n\n      if (props.bounds != null) {\n        this.leafletElement.fitBounds(props.bounds, props.boundsOptions);\n      }\n\n      this.contextValue = {\n        layerContainer: this.leafletElement,\n        map: this.leafletElement\n      };\n\n      _get(_getPrototypeOf(Map.prototype), \"componentDidMount\", this).call(this);\n\n      this.forceUpdate(); // Re-render now that leafletElement is created\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(prevProps) {\n      if (this._ready === false) {\n        this._ready = true;\n\n        if (this.props.whenReady) {\n          this.leafletElement.whenReady(this.props.whenReady);\n        }\n      }\n\n      _get(_getPrototypeOf(Map.prototype), \"componentDidUpdate\", this).call(this, prevProps);\n\n      this.updateLeafletElement(prevProps, this.props);\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      _get(_getPrototypeOf(Map.prototype), \"componentWillUnmount\", this).call(this);\n\n      this.leafletElement.off('move', this.onViewportChange);\n      this.leafletElement.off('moveend', this.onViewportChanged); // The canvas renderer uses requestAnimationFrame, making a deferred call to a deleted object\n      // When preferCanvas is set, use simpler teardown logic\n\n      if (this.props.preferCanvas === true) {\n        this.leafletElement._initEvents(true);\n\n        this.leafletElement._stop();\n      } else {\n        this.leafletElement.remove();\n      }\n    }\n  }, {\n    key: \"shouldUpdateCenter\",\n    value: function shouldUpdateCenter(next, prev) {\n      if (!prev) return true;\n      next = normalizeCenter(next);\n      prev = normalizeCenter(prev);\n      return next[0] !== prev[0] || next[1] !== prev[1];\n    }\n  }, {\n    key: \"shouldUpdateBounds\",\n    value: function shouldUpdateBounds(next, prev) {\n      return prev ? !latLngBounds(next).equals(latLngBounds(prev)) : true;\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      return React.createElement(\"div\", {\n        className: this.className,\n        id: this.props.id,\n        ref: this.bindContainer,\n        style: this.props.style,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 333\n        },\n        __self: this\n      }, this.contextValue ? React.createElement(LeafletProvider, {\n        value: this.contextValue,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 339\n        },\n        __self: this\n      }, this.props.children) : null);\n    }\n  }]);\n\n  return Map;\n}(MapEvented);\n\nexport { Map as default };","map":{"version":3,"sources":["/home/linux/Escritorio/prueba/proyecto1/src/componentes/MiMapa.js"],"names":["latLngBounds","Map","LeafletMap","React","LeafletProvider","MapEvented","updateClassName","omit","LatLng","LatLngBounds","LeafletContext","Point","Viewport","OTHER_PROPS","normalizeCenter","pos","Array","isArray","lat","lon","lng","props","viewport","center","undefined","zoom","_ready","_updating","onViewportChange","leafletElement","getCenter","getZoom","onViewportChanged","bindContainer","container","className","options","fromProps","toProps","animate","bounds","boundsOptions","boxZoom","doubleClickZoom","dragging","keyboard","maxBounds","scrollWheelZoom","tap","touchZoom","useFlyTo","c","z","flyTo","setView","shouldUpdateCenter","setZoom","shouldUpdateBounds","setMaxBounds","flyToBounds","fitBounds","enable","disable","createLeafletElement","on","contextValue","layerContainer","map","forceUpdate","prevProps","whenReady","updateLeafletElement","off","preferCanvas","_initEvents","_stop","remove","next","prev","equals","id","style","children"],"mappings":"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","sourcesContent":["\nimport {\n  latLngBounds,\n  Map as LeafletMap,\n  type CRS,\n  type Renderer\n} from 'leaflet'\nimport React, { type Node } from 'react'\n\nimport { LeafletProvider } from './context'\nimport MapEvented from './MapEvented'\nimport updateClassName from './utils/updateClassName'\nimport omit from './utils/omit'\nimport{\n  LatLng,\n  LatLngBounds,\n  LeafletContext,\n  Point,\n  Viewport,\n} from './types'\n\nconst OTHER_PROPS = [\n  'children',\n  'className',\n  'id',\n  'style',\n  'useFlyTo',\n  'whenReady',\n]\n\nconst normalizeCenter = (pos: LatLng): [number, number] => {\n  return Array.isArray(pos)\n    ? [pos[0], pos[1]]\n    : [pos.lat, pos.lon ? pos.lon : pos.lng]\n}\n\ntype LeafletElement = LeafletMap\n\ntype ZoomOption = boolean | 'center'\ntype Props = {\n  [key: string]: any,\n  // Leaflet options\n  preferCanvas?: boolean,\n  attributionControl?: boolean,\n  zoomControl?: boolean,\n  closePopupOnClick?: boolean,\n  zoomSnap?: number,\n  zoomDelta?: number,\n  trackResize?: boolean,\n  boxZoom?: boolean,\n  doubleClickZoom?: ZoomOption,\n  dragging?: boolean,\n  crs?: CRS,\n  center?: LatLng,\n  zoom?: number,\n  minZoom?: number,\n  maxZoom?: number,\n  maxBounds?: LatLngBounds,\n  renderer?: Renderer,\n  zoomAnimation?: boolean,\n  zoomAnimationThreshold?: number,\n  fadeAnimation?: boolean,\n  markerZoomAnimation?: boolean,\n  transform3DLimit?: number,\n  inertia?: boolean,\n  inertiaDeceleration?: number,\n  inertiaMaxSpeed?: number,\n  easeLinearity?: number,\n  worldCopyJump?: boolean,\n  maxBoundsViscosity?: number,\n  keyboard?: boolean,\n  keyboardPanDelta?: number,\n  scrollWheelZoom?: ZoomOption,\n  wheelDebounceTime?: number,\n  wheelPxPerZoomLevel?: number,\n  tap?: boolean,\n  tapTolerance?: number,\n  touchZoom?: ZoomOption,\n  bounceAtZoomLimits?: boolean,\n  // Additional options\n  animate?: boolean,\n  bounds?: LatLngBounds,\n  boundsOptions?: {\n    paddingTopLeft?: Point,\n    paddingBottomRight?: Point,\n    padding?: Point,\n    maxZoom?: number,\n  },\n  children: Node,\n  className?: string,\n  id?: string,\n  style?: Object,\n  useFlyTo?: boolean,\n  viewport?: Viewport,\n  whenReady?: () => void,\n}\n\nexport default class Map extends MapEvented<LeafletElement, Props> {\n  className: ?string\n  contextValue: ?LeafletContext\n  container: ?HTMLDivElement\n  viewport: Viewport = {\n    center: undefined,\n    zoom: undefined,\n  }\n\n  _ready: boolean = false\n  _updating: boolean = false\n\n  constructor(props: Props) {\n    super(props)\n    this.className = props.className\n  }\n\n  createLeafletElement(props: Props): LeafletElement {\n    const { viewport, ...options } = props\n    if (viewport) {\n      if (viewport.center) {\n        options.center = viewport.center\n      }\n      if (typeof viewport.zoom === 'number') {\n        options.zoom = viewport.zoom\n      }\n    }\n    return new LeafletMap(this.container, options)\n  }\n\n  updateLeafletElement(fromProps: Props, toProps: Props) {\n    this._updating = true\n\n    const {\n      animate,\n      bounds,\n      boundsOptions,\n      boxZoom,\n      center,\n      className,\n      doubleClickZoom,\n      dragging,\n      keyboard,\n      maxBounds,\n      scrollWheelZoom,\n      tap,\n      touchZoom,\n      useFlyTo,\n      viewport,\n      zoom,\n    } = toProps\n\n    updateClassName(this.container, fromProps.className, className)\n\n    if (viewport && viewport !== fromProps.viewport) {\n      const c = viewport.center ? viewport.center : center\n      const z = viewport.zoom == null ? zoom : viewport.zoom\n      if (useFlyTo === true) {\n        this.leafletElement.flyTo(c, z, { animate })\n      } else {\n        this.leafletElement.setView(c, z, { animate })\n      }\n    } else if (center && this.shouldUpdateCenter(center, fromProps.center)) {\n      if (useFlyTo === true) {\n        this.leafletElement.flyTo(center, zoom, { animate })\n      } else {\n        this.leafletElement.setView(center, zoom, { animate })\n      }\n    } else if (typeof zoom === 'number' && zoom !== fromProps.zoom) {\n      if (fromProps.zoom == null) {\n        this.leafletElement.setView(center, zoom)\n      } else {\n        this.leafletElement.setZoom(zoom)\n      }\n    }\n\n    if (maxBounds && this.shouldUpdateBounds(maxBounds, fromProps.maxBounds)) {\n      this.leafletElement.setMaxBounds(maxBounds)\n    }\n\n    if (\n      bounds &&\n      (this.shouldUpdateBounds(bounds, fromProps.bounds) ||\n        boundsOptions !== fromProps.boundsOptions)\n    ) {\n      if (useFlyTo === true) {\n        this.leafletElement.flyToBounds(bounds, boundsOptions)\n      } else {\n        this.leafletElement.fitBounds(bounds, boundsOptions)\n      }\n    }\n\n    if (boxZoom !== fromProps.boxZoom) {\n      if (boxZoom === true) {\n        this.leafletElement.boxZoom.enable()\n      } else {\n        this.leafletElement.boxZoom.disable()\n      }\n    }\n\n    if (doubleClickZoom !== fromProps.doubleClickZoom) {\n      if (doubleClickZoom === true) {\n        this.leafletElement.doubleClickZoom.enable()\n      } else {\n        this.leafletElement.doubleClickZoom.disable()\n      }\n    }\n\n    if (dragging !== fromProps.dragging) {\n      if (dragging === true) {\n        this.leafletElement.dragging.enable()\n      } else {\n        this.leafletElement.dragging.disable()\n      }\n    }\n\n    if (keyboard !== fromProps.keyboard) {\n      if (keyboard === true) {\n        this.leafletElement.keyboard.enable()\n      } else {\n        this.leafletElement.keyboard.disable()\n      }\n    }\n\n    if (scrollWheelZoom !== fromProps.scrollWheelZoom) {\n      if (scrollWheelZoom === true || typeof scrollWheelZoom === 'string') {\n        this.leafletElement.options.scrollWheelZoom = scrollWheelZoom\n        this.leafletElement.scrollWheelZoom.enable()\n      } else {\n        this.leafletElement.scrollWheelZoom.disable()\n      }\n    }\n\n    if (tap !== fromProps.tap) {\n      if (tap === true) {\n        this.leafletElement.tap.enable()\n      } else {\n        this.leafletElement.tap.disable()\n      }\n    }\n\n    if (touchZoom !== fromProps.touchZoom) {\n      if (touchZoom === true || typeof touchZoom === 'string') {\n        this.leafletElement.options.touchZoom = touchZoom\n        this.leafletElement.touchZoom.enable()\n      } else {\n        this.leafletElement.touchZoom.disable()\n      }\n    }\n\n    this._updating = false\n  }\n\n  onViewportChange = () => {\n    const center = this.leafletElement.getCenter()\n    this.viewport = {\n      center: center ? [center.lat, center.lng] : undefined,\n      zoom: this.leafletElement.getZoom(),\n    }\n    if (this.props.onViewportChange && !this._updating) {\n      this.props.onViewportChange(this.viewport)\n    }\n  }\n\n  onViewportChanged = () => {\n    if (this.props.onViewportChanged && !this._updating) {\n      this.props.onViewportChanged(this.viewport)\n    }\n  }\n\n  componentDidMount() {\n    const props = omit(this.props, ...OTHER_PROPS)\n    this.leafletElement = this.createLeafletElement(props)\n\n    this.leafletElement.on('move', this.onViewportChange)\n    this.leafletElement.on('moveend', this.onViewportChanged)\n\n    if (props.bounds != null) {\n      this.leafletElement.fitBounds(props.bounds, props.boundsOptions)\n    }\n\n    this.contextValue = {\n      layerContainer: this.leafletElement,\n      map: this.leafletElement,\n    }\n\n    super.componentDidMount()\n    this.forceUpdate() // Re-render now that leafletElement is created\n  }\n\n  componentDidUpdate(prevProps: Props) {\n    if (this._ready === false) {\n      this._ready = true\n      if (this.props.whenReady) {\n        this.leafletElement.whenReady(this.props.whenReady)\n      }\n    }\n\n    super.componentDidUpdate(prevProps)\n    this.updateLeafletElement(prevProps, this.props)\n  }\n\n  componentWillUnmount() {\n    super.componentWillUnmount()\n\n    this.leafletElement.off('move', this.onViewportChange)\n    this.leafletElement.off('moveend', this.onViewportChanged)\n\n    // The canvas renderer uses requestAnimationFrame, making a deferred call to a deleted object\n    // When preferCanvas is set, use simpler teardown logic\n    if (this.props.preferCanvas === true) {\n      this.leafletElement._initEvents(true)\n      this.leafletElement._stop()\n    } else {\n      this.leafletElement.remove()\n    }\n  }\n\n  bindContainer = (container: ?HTMLDivElement): void => {\n    this.container = container\n  }\n\n  shouldUpdateCenter(next: LatLng, prev: LatLng) {\n    if (!prev) return true\n    next = normalizeCenter(next)\n    prev = normalizeCenter(prev)\n    return next[0] !== prev[0] || next[1] !== prev[1]\n  }\n\n  shouldUpdateBounds(next: LatLngBounds, prev: LatLngBounds) {\n    return prev ? !latLngBounds(next).equals(latLngBounds(prev)) : true\n  }\n\n  render() {\n    return (\n      <div\n        className={this.className}\n        id={this.props.id}\n        ref={this.bindContainer}\n        style={this.props.style}>\n        {this.contextValue ? (\n          <LeafletProvider value={this.contextValue}>\n            {this.props.children}\n          </LeafletProvider>\n        ) : null}\n      </div>\n    )\n  }\n}"]},"metadata":{},"sourceType":"module"}
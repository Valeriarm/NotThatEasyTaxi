{"ast":null,"code":"var fs = require('fs');\n\nvar path = require('path');\n\nvar util = require('util');\n\nvar http = require('http');\n\nvar events = require('events');\n\nvar WebSocket = require('ws');\n\nvar endpoint = require('endpoint'); // Load library\n\n\nvar library = {};\nfs.readdirSync(path.resolve(__dirname, 'lib')).filter(function (filename) {\n  return filename[0] !== '.';\n}).forEach(function (filename) {\n  var filepath = path.resolve(__dirname, 'lib', filename);\n  library[path.basename(filename, '.js')] = require(filepath);\n}); // Main constructor\n\nfunction WebKitInspector(port, host, href, callback) {\n  if (!(this instanceof WebKitInspector)) {\n    return new WebKitInspector(port, host, href, callback);\n  }\n\n  this.closed = false;\n  this._callbacks = {};\n  this._id = 0;\n  this.debug = false; // Add library domains\n\n  var domains = Object.keys(library);\n\n  for (var i = 0, l = domains.length; i < l; i++) {\n    this[domains[i]] = new library[domains[i]](this);\n  } // Setup host and port parameters\n\n\n  if (typeof port !== 'number') {\n    throw new Error('A port number must be speficed');\n  }\n\n  if (typeof host !== 'string') {\n    throw new Error('A host name must be speficed');\n  }\n\n  if (typeof href !== 'string') {\n    throw new Error('A page url must be speficed');\n  } // Add callback to connect event\n\n\n  if (callback) this.once('connect', callback); // Try to connect to WebKit Server\n\n  this._tryConnect(port, host, href, 0, 2000);\n}\n\nutil.inherits(WebKitInspector, events.EventEmitter);\nmodule.exports = WebKitInspector;\n\nWebKitInspector.prototype._tryConnect = function (port, host, href, use, timeout) {\n  var self = this;\n  var time = Date.now();\n  var req = http.get('http://' + host + ':' + port + '/json', function (res) {\n    res.pipe(endpoint(function (err, buffer) {\n      if (err) return self.emit('error', err); // Check that .close wasn't executed\n\n      if (self.closed) return; // Find the websocket url pointing to the given url\n\n      var wsUrl = null;\n      var pages = JSON.parse(buffer.toString());\n\n      for (var i = 0, l = pages.length; i < l; i++) {\n        if (pages[i].url === href) {\n          wsUrl = pages[i].webSocketDebuggerUrl || false;\n          break;\n        }\n      } // Check that a page was found\n\n\n      if (wsUrl === null) {\n        return self.emit('error', new Error('No page with the given url was found'));\n      } // Check that a WebSocket connection is allowed\n\n\n      if (wsUrl === false) {\n        return self.emit('error', new Error('Another inspector is already listning'));\n      } // Connect to the WebSocket\n\n\n      self._ws = new WebSocket(wsUrl);\n\n      self._ws.on('message', self._respond.bind(self));\n\n      self._ws.on('error', self.emit.bind(self, 'error'));\n\n      self._ws.once('open', self.emit.bind(self, 'connect'));\n\n      self._ws.once('close', self.close.bind(self));\n    }));\n  }); // Send request error to main object\n\n  req.on('error', function (err) {\n    // In case it was a ECONNREFUSED error\n    // and there is time left,\n    // and .close hasn't been called\n    var timeUse = time - Date.now() + use;\n\n    if (err.code === 'ECONNREFUSED' && timeUse + 100 < timeout && self.closed === false) {\n      // Try to connect again after 100 ms\n      setTimeout(function () {\n        self._tryConnect(port, host, href, timeUse, timeout);\n      }, 100);\n      return;\n    } // Emit error\n\n\n    self.emit('error', err);\n  });\n};\n\nWebKitInspector.prototype._splitArgs = function (argsList) {\n  var args = [],\n      callback; // Split callback from argsList, asumes that callback is the last argument\n\n  if (args.length === 1) {\n    callback = argsList[0];\n  } else {\n    for (var i = 0, l = argsList.length; i < l; i++) {\n      args.push(argsList[i]);\n    }\n\n    callback = args.pop();\n  } // check that a callback was speficed\n\n\n  if (typeof callback !== 'function') {\n    throw new Error('missing callback');\n  }\n\n  return {\n    args: args,\n    callback: callback\n  };\n};\n\nWebKitInspector.prototype._request = function (method, params, callback) {\n  var self = this;\n  var newId = ++this._id;\n  var request = {\n    'id': newId,\n    'method': method,\n    'params': params\n  };\n  this._callbacks[newId] = callback;\n\n  if (this.debug) {\n    console.log('=== Send request #' + newId + ' ===');\n    console.log(util.inspect(request, false, Infinity, true));\n    console.log('=== message end ===');\n  }\n\n  this._ws.send(JSON.stringify(request), function (err) {\n    if (err) {\n      delete self._callbacks[newId];\n      callback(err, null);\n    }\n  });\n};\n\nWebKitInspector.prototype._respond = function (message) {\n  message = JSON.parse(message); // respond from a request\n\n  if (message.id) {\n    if (this.debug) {\n      console.log('=== Got response #' + message.id + ' ===');\n      console.log(util.inspect(message, false, Infinity, true));\n      console.log('=== message end ===');\n    }\n\n    var callback = this._callbacks[message.id]; // Emit error if callback isn't defined\n\n    if (callback === undefined) {\n      this.emit('error', new Error('atempt to fire a missing callback'));\n      return;\n    }\n\n    delete this._callbacks[message.id];\n\n    if (message.error) {\n      var err = new Error(message.error.message);\n      err.code = message.error.code;\n      callback.call(null, err, null);\n    } else {\n      callback.call(null, null, message.result);\n    }\n  } // respond from a notification\n  else {\n      if (this.debug) {\n        console.log('=== Got event ::' + message.method + ' ===');\n        console.log(util.inspect(message, false, Infinity, true));\n        console.log('=== message end ===');\n      }\n\n      var method = message.method.split('.');\n      this[method[0]].emit(method[1], message.params);\n    }\n};\n\nWebKitInspector.prototype.close = function (callback) {\n  var self = this;\n  if (this.closed) return;\n  this.closed = true; // Execute callback one close event emits\n\n  if (typeof callback === 'function') this.once('close', callback); // Close WebSocket or just emit close\n\n  if (this._ws && this._ws.readyState !== WebSocket.CLOSED) {\n    this._ws.once('close', function () {\n      // the ws module do sometimes return an exit code as a argument\n      self.emit('close');\n    });\n\n    this._ws.close();\n  } else {\n    this.emit('close');\n  }\n};","map":null,"metadata":{},"sourceType":"script"}